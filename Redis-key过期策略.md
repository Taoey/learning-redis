# 过期策略

> Redis会将设置了过期的键都放到一个字典中

过期策略：

- 定时扫描策略（集中处理）
- 惰性删除（零散处理）

## 一、惰性删除

客户端访问这个 key 的时候，redis 对 key 的过期时间进行检查，如果过期 了就立即删除



## 二、定时扫描

### 1、贪心扫描

Redis 默认会**10次/s**过期扫描，过期扫描不会遍历过期字典中所有的 key，而是 采用了一种简单的贪心策略。

```
1、从过期字典中随机 20 个 key； 
2、删除这 20 个 key 中已经过期的 key； 
3、如果过期的 key 比率超过 1/4，那就重复步骤 1；
```

同时，为了保证过期扫描不会出现**循环过度**，导致线程卡死现象，算法还增加了扫描时 间的上限，默认不会超过 **25ms**。

### 2、避免过多键同时过期

设想一个大型的 Redis 实例中所有的 key 在同一时间过期了，会出现怎样的结果？

-  Redis 会持续扫描过期字典 (循环多次)，直到过期字典中过期的 key 变得稀 疏，才会停止 (循环次数明显下降)。这就会导致线上读写请求出现明显的卡顿现象。

- 导致这 种卡顿的另外一种原因是内存管理器需要频繁回收内存页，这也会产生一定的 CPU 消耗。



解决问题：

有大量需要设置过期的key时，需要设置一个随机范围，不能全在一个时间过期。例如 在目标过期时间上增加一天的随机时间 redis.expire_at(key, random.randint(86400) + expire_ts)。



## 三、从库数据过期

从库对过期数据的处理是被动的。主库在 key 到期时，会在 AOF文件里增加一条 del 指令，同步到所有的从库，从库通过执行这条 del 指令来删除过期的key。

因为指令同步是异步进行的，所以主库过期的 key 的 del 指令没有及时同步到从库的话，会出现主从数据的不一致，主库没有的数据在从库里还存在，比如上一节的集群环境分布式锁的算法漏洞就是因为这个同步延迟产生的。









